Задание № 1
В Таблице Table_SQL данные о посещении абонентами некоторой локации. 
Необходимо с помощью алгоритма на языке SQL привести её 
к следующему виду:
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
subs_id          START_DTTM    END_DTTM
1452214526665    01.01.2021    05.01.2021
1452214526665    07.01.2021    11.01.2021
1452214526665    13.01.2021    13.01.2021
1452214526665    18.01.2021    26.01.2021
1452214526665    28.01.2021    31.01.2021
2458741444746    03.01.2021    06.01.2021
2458741444746    27.01.2021    31.01.2021
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Table_SQL

SubsID              DateID  
1452214526665    01.01.2021
1452214526665    02.01.2021
1452214526665    03.01.2021 1
1452214526665    04.01.2021 1
1452214526665    05.01.2021 0
1452214526665    07.01.2021 1
1452214526665    08.01.2021 1
1452214526665    09.01.2021 1
1452214526665    10.01.2021 1
1452214526665    11.01.2021 1
1452214526665    18.01.2021 0
1452214526665    19.01.2021 1
1452214526665    20.01.2021 1
1452214526665    21.01.2021 1
1452214526665    22.01.2021 1
1452214526665    23.01.2021 1
1452214526665    24.01.2021 1
1452214526665    25.01.2021 1
1452214526665    26.01.2021 0
1452214526665    28.01.2021
1452214526665    29.01.2021
1452214526665    30.01.2021
1452214526665    31.01.2021
2458741444746    03.01.2021
2458741444746    04.01.2021
2458741444746    05.01.2021
2458741444746    06.01.2021
2458741444746    27.01.2021
2458741444746    28.01.2021
2458741444746    29.01.2021
2458741444746    30.01.2021
2458741444746    31.01.2021



----------------------
РЕШЕНИЕ
Для преобразования таблицы посещений в таблицу сессий, где сессия прерывается, 
	если следующий день отсутствует, можно воспользоваться оконными функциями в SQL. 
	Алгоритм основан на использовании функции LAG для определения разрыва между датами.

Вот пример SQL-запроса, который решает данную задачу:

WITH RankedVisits AS (
    SELECT 
        SubsID, 
        DateID,
        LAG(DateID) OVER (PARTITION BY SubsID ORDER BY DateID) AS PrevDateID
    FROM 
        Table_SQL
),
SessionGroups AS (
    SELECT 
        SubsID, 
        DateID,
        CASE 
            WHEN PrevDateID IS NULL OR DateID <> DATEADD(DAY, 1, PrevDateID) THEN 1
            ELSE 0
        END AS IsNewSession
    FROM 
        RankedVisits
),
SessionNumbers AS (
    SELECT 
        SubsID, 
        DateID,
        SUM(IsNewSession) OVER (PARTITION BY SubsID ORDER BY DateID) AS SessionNumber
    FROM 
        SessionGroups
),
SessionRanges AS (
    SELECT 
        SubsID, 
        MIN(DateID) AS START_DTTM, 
        MAX(DateID) AS END_DTTM
    FROM 
        SessionNumbers
    GROUP BY 
        SubsID, SessionNumber
)
SELECT 
    SubsID, 
    START_DTTM, 
    END_DTTM
FROM 
    SessionRanges
ORDER BY 
    SubsID, START_DTTM;
### Объяснение:

1. RankedVisits: Используем функцию LAG для получения предыдущей даты посещения для каждого абонента (SubsID). 
	Это позволяет нам определить, является ли текущая дата продолжением предыдущей.

2. SessionGroups: Определяем, является ли текущая дата началом новой сессии. 
	Это происходит, если предыдущая дата отсутствует или не является днем перед текущей.

3. SessionNumbers: Присваиваем каждой сессии уникальный номер. 
	Это достигается с помощью аккумуляции с использованием функции SUM по флагу IsNewSession.

4. SessionRanges: Для каждой уникальной сессии (группы с одинаковым SessionNumber) определяем начало и конец сессии с помощью MIN и MAX.

5. Финальный SELECT: Извлекаем и сортируем результаты, чтобы получить список сессий.

Этот запрос создаст таблицу сессий, где каждая сессия начинается и заканчивается в указанный диапазон дат. 
	Убедитесь, что в вашей базе данных поддерживаются оконные функции, так как они используются для реализации этого решения.





----------------------
Текс запроса:

Задание № 2

Написать запрос, который выведет модель последнего устройства у клиента (user_id / vendor_name / start_date / end_date)

Table
-----------------------------------------------------------------------------------------------------------------------------------------
              Справочник мобильных устройств (devices):
    device_id    vendor_name        price
    1            Apple             85000                                                                                       
    2            Samsung           60000                                                                                   
    3            Xiaomi            25000                                                                               
    4            Huawei            30000



    История смен мобильных устройств пользователями (history_log):
    user_id    device_id       start_date    end_date
    1            1            21.02.2020    16.08.2020
    1            2            17.08.2020    18.10.2020
    1            3            19.10.2020    13.02.2021
    2            2            18.01.2019    22.03.2021
    2            2            23.03.2021    31.12.2999
    3            2            02.02.2015    03.09.2017
    3            3            04.09.2017    21.03.2019
    3            1            22.03.2019    02.02.2021

----------------------
РЕШЕНИЕ


SELECT * 
FROM
(    
SELECT
    user_id
    ,vendor_name
    ,start_date
    ,end_dat
    row_number() over (PARTITION BY user_id order by end_date desc) as _rank
FROM t1
    LEFT JOIN t2 ON t1.device_id = t2.device_id
    )
    
WHERE   _rank = 1 
    
   
    
    














