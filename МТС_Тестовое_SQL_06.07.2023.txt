Представлены таблицы A и B:

select * from A                select * from B
+---+---+                            +---+---+
|id |val|                            |id |val|
+---+---+                            +---+---+
|1  |A  |                            |1  |A  |
|2  |B  |                            |2  |B  |
|3  |C  |                            |3  |C  |                            
+---+---+                            |4  |A  |
                                     +---+---+

Будут ли отличаться результаты, возвращаемые следующими запросами?

1)
select *
from A left join B
    on A.id = B.id 
    and B.val = 'A'

2)
select *
from A left join B
    on A.id = B.id 
where B.val = 'A'

1 A A
2 B null
3 C null



-------------------------
-= задача на категории =-
-------------------------
Представлены таблицы product (информация о том, какой категории принадлежит продукт в указанном интервале дат) 
и sale (факты продаж продукта с указанием даты продажи, цены за единицу товара и количества купленных единиц):

select * from product
+---------+-----------+----------+----------+
|prod_nm  |prod_cat   |eff_dt    |exp_dt    |
+---------+-----------+----------+----------+
|Продукт 1|Категория 1|2020-01-01|2020-01-31|
|Продукт 1|Категория 2|2020-02-01|2020-02-28|
|Продукт 2|Категория 3|2020-01-01|2020-02-28|
+---------+-----------+----------+----------+

select * from sale
+----------+---------+-----+---+
|sale_dt   |prod_nm  |price|cnt|
+----------+---------+-----+---+
|2020-01-10|Продукт 1|10   |5  |
|2020-01-25|Продукт 1|15   |2  |
|2020-01-18|Продукт 2|0.9  |300|
|2020-02-17|Продукт 1|12   |7  |
+----------+---------+-----+---+

Необходимо написать запрос, возвращающий общую выручку по каждой категории:
+-----------+---------+
|prod_cat   |total_amt|
+-----------+---------+
|Категория 1|80       |
|Категория 2|84       |
|Категория 3|270      |
+-----------+---------+


SELECT
t1.prod_cat
,SUM(t1.price * t1.cnt) AS total_amt



FROM
        (
        SELECT
        s.sale_dt
        ,s.prod_nm
        ,s.price
        ,s.cnt
        ,p.prod_cat
        
        FROM sale s
        LEFT JOIN product p 
        ON s.prod_nm = p.prod_nm AND s.sale_dt >= p.eff_dt AND s.sale_dt <= p.exp_dt
        ) t1

GROUP BY 1
HAVING SUM(t1.price * t1.cnt) > 100
ORDER BY 1




drop table A;

create table A (
    id number primary key,
    val number not null);

insert into A (id) values (1);
insert into A (id,val) values (1,1); 
insert into A (id,val) values (1,2);
update A set val=val+1;
commit;




Есть таблица абонентов с записями, которые пришли в разное время. 
Поле для определения уникальности записи appn. 
Дата загрузки записи определена в поле raw_dt:
select * from abnt
+----+------------+-------------+----------+----------+
|appn|msisdn      |tarif_plan_id|account_id|raw_dt    |
+----+------------+-------------+----------+----------+
|1   |+71234567890|4375         |4979      |2020-01-01|
|1   |+71234567890|5842         |4979      |2020-01-10|
|1   |+71234567890|5842         |589783    |2020-01-20|
|2   |+71111111111|4563         |5326      |2020-01-01|
|2   |+72222222222|4563         |0832      |2020-01-20|
|2   |+72222222222|4563         |0832      |2020-01-25|
+----+------------+-------------+----------+----------+

Необходимо написать запрос, который вернет последнюю загруженную запись по абоненту:
+----+------------+-------------+----------+----------+
|appn|msisdn      |tarif_plan_id|account_id|raw_dt    |
+----+------------+-------------+----------+----------+
|1   |+71234567890|5842         |589783    |2020-01-20|
|2   |+72222222222|4563         |0832      |2020-01-25|
+----+------------+-------------+----------+----------+


SELECT
    appn,
    msisdn,
    tarif_plan_id,
    account_id,
    MAX(raw_dt)
FROM abnt
GROUP BY 1,2,3,4



WITH t1 AS (
SELECT
    appn,
    MAX(raw_dt) AS max_date
FROM abnt 
GROUP BY 1 )

SELECT t2.*  
FROM t1
LEFT JOIN abnt t2 ON t1.appn = t2.appn AND t1.max_date =  t2.raw_dt


SELECT *
FROM abnt
WHERE (appn,raw_dt) IN (SELECT
    appn,
    MAX(raw_dt) AS max_date
FROM abnt 
GROUP BY 1)


----------------------------------------------------------

with a as (
     select 'Красный' as color union all
    select 'Зеленый' as color union all
    select 'Синий' as color union all
    select 'Желтый' as color union all
    select 'Фиолетовый' as color union all
    select 'Пурпурный' as color union all
    select 'Белый' as color)
 
Напишите запрос, выдающий пары разных цветов, но без дубликатов, если их смешать. Т.е.
Красный - Красный - не допустимо
Красный - Зеленый
Зеленый - Красный - не допустимо 
…
Красный – Синий

SELECT t1.a, t2.a
FROM a t1 CROSS JOIN a t2
WHERE  t1.a > t2.a




----------------------------------------------------------

Есть таблица абонентов с историей изменений. Каждая запись по абоненту действует в пределах периода c valid_from_dt по valid_to_dt. 
Если одна запись закрывается, следующая запись начинается с той же даты.  
По каждому абоненту должна быть только одна действующая запись в интервале [valid_from_dt, valid_to_dt). 

select * from abnt
+----+-------------+-----------+------------+-------------+----------+
|appn|valid_from_dt|valid_to_dt|msisdn      |tarif_plan_id|account_id|
+----+-------------+-----------+------------+-------------+----------+
|1   |2020-01-01   |2020-01-10 |+71234567890|4375         |4979      |
|1   |2020-01-10   |2020-01-25 |+71234567890|5842         |4979      |
|1   |2020-01-20   |2020-01-31 |+71234567890|5842         |589783    |
|2   |2020-01-01   |2020-01-23 |+71111111111|4563         |5326      |
|2   |2020-01-20   |2020-01-25 |+72222222222|4563         |0832      |
|2   |2020-01-25   |2020-01-31 |+72222222222|4563         |0832      |
+----+-------------+-----------+------------+-------------+----------+

Необходимо написать запрос, который вернет те записи, у которых некорректная дата закрытия.
+----+-------------+-----------+------------+-------------+----------+
|appn|valid_from_dt|valid_to_dt|msisdn      |tarif_plan_id|account_id|
+----+-------------+-----------+------------+-------------+----------+
|1   |2020-01-10   |2020-01-25 |+71234567890|5842         |4979      |
|2   |2020-01-01   |2020-01-23 |+71111111111|4563         |5326      |
+----+-------------+-----------+------------+-------------+----------+


SELECT
    appn,
    valid_from_dt,
    valid_to_dt,
    LEAD(valid_from_dt) OVER (PARTITION BY appn ORDER BY valid_from_dt) AS nxt_day


FROM abnt
WHERE nxt_day < valid_to_dt


+----+-------------+-----------+------------+-------------+----------+
|appn|valid_from_dt|valid_to_dt|nxt_day     |tarif_plan_id|account_id|
+----+-------------+-----------+------------+-------------+----------+
|1   |2020-01-01   |2020-01-10 |2020-01-10  |4375         |4979      |
|1   |2020-01-10   |2020-01-25 |2020-01-20  |5842         |4979      |
|1   |2020-01-20   |2020-01-31 |NULL        |5842         |589783    |
|2   |2020-01-01   |2020-01-23 |2020-01-20  |4563         |5326      |
|2   |2020-01-20   |2020-01-25 |2020-01-25  |4563         |0832      |
|2   |2020-01-25   |2020-01-31 |NULL        |4563         |0832      |
+----+-------------+-----------+------------+-------------+----------+























